// map stores a stack of box-shadow definitions, in order of size
@shadows: {
    0: 0 1px 1px 0 rgba(0, 0, 0, 0.16);
    1: 0 1px 3px rgba(0, 0, 0, 0.12), 0 1px 2px rgba(0, 0, 0, 0.24);
    2: 0 3px 6px rgba(0, 0, 0, 0.16), 0 3px 6px rgba(0, 0, 0, 0.23);
    3: 0 10px 20px rgba(0, 0, 0, 0.19), 0 6px 6px rgba(0, 0, 0, 0.23);
    4: 0 14px 28px rgba(0, 0, 0, 0.25), 0 10px 10px rgba(0, 0, 0, 0.22);
    5: 0 19px 38px rgba(0, 0, 0, 0.30), 0 15px 12px rgba(0, 0, 0, 0.22);
}
    
// corresponding map to store hover-state box-shadows. When a hover shadow isn't defined, it must reference
// the shadows map as there is no way to effectively null-check a map value
@hoverShadows: {
    0: 0 3px 6px 0 rgba(0, 0, 0, 0.16);
    1: @shadows[1];
    2: @shadows[2];
    3: @shadows[3];
    4: @shadows[4];
    5: @shadows[5];
}

// mixin for applying the shadow and its hover state
// enable hover state by passing .umb-shadow(level, true);
.umb-box-shadow(@level, @hover: false) {
    box-shadow: @shadows[$@level];
    .umb-box-shadow--hover(@level, @hover);
}

// mixin for hover shadow, with transition
.umb-box-shadow--hover(@level, @hover: false) when (@hover = true) {    
    &:hover {
        box-shadow: @hoverShadows[$@level];            
        transition: box-shadow 150ms ease-in-out;
    }
}

// ---------------------------------------
// loop for generating .shadow-depth-n classes (from 1 - 5)
// ---------------------------------------
.umb-box-shadow-loop (@i) when (@i > -1) {
    .shadow-depth-@{i} {
        box-shadow: @shadows[$@i];
        .umb-box-shadow--hover(@i);
    }

    .umb-box-shadow-loop(@i - 1);
}

.umb-box-shadow-loop (5);
